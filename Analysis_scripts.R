#####################################################
# Data Analysis in R-Metabolomics data Prof Prakash #
#####################################################
# Author(s): Shiv
# Version: 23032015
# Input: ".txt" file from XCMS Metabolomics data (data matrix generated by Peter Benke)
# Software: XCMS
## SCRIPT for Rice metabolomics data from Ram (NUS-DBS)
#MS analysis performed by Peter Benke
#MS date: 2014 
#Data location 1 (statistician) (both raw and processed) : F:\Projects\NUS\RiceProject\Metabolomics\data
#Data location 2 (biologist) : Peter Benke
#Sample extraction was performed by Ram/Peter (NERI), MS analysis by Peter Benke (NERI)
# The file "RiceMetabolomicsData.txt" contains the metabolomics profiles generated in positive mode by Peter Benke.
## Data analysis for positive mode

#To identify a set of metabolites characteristic of gain of function and loss of function mutant in Rice
#There are 4 biological replicates and two technical replicate for each biological replicate- 
#Total number of sample = 6*4*2= 48 + 9 Blanks --> 57 columns

#The profiles are generated for  #(first X denotes biorep and second X techrep number)
#Lines                  GivenName       ModifiedName(SampleGroup)
#WT                     - WTXTX         WT
#Mutant                 - MXTX          MU
#Ectopic expression     - EXTX          EC
#RNAi neutral           - RNXTX         RN
#RNAi lines             - RXTX          RL
#Complementation strain - COXTX         CO
#Blank                  - BlankX        BL

#############
# Clear all #
#############
rm(list = ls()) # Clears the workspace
graphics.off() # Close all windows

##### Loading required packages 

library(ggplot2)
library(preprocessCore)
library(data.table)
library(vegan)
library(gtools)
library(stringi)
library(reshape2)
library(gridExtra)
library(multtest)
library(VennDiagram)

#############
# User      #
# Specific  #
# Variables #
#############

#################################
# Reading in the mass spec data #
#################################

setwd('../data')

### RUN THE USER CREATED FUNCTIONS FIRST

# For PB 2 week dataset generated by Shiv  in xcms

mzfilename<-"PB_240315_xcms1_38.tsv"
ms_data_total_all<-read.table(mzfilename,sep="\t",header=T,check.names=FALSE,row.names=1)
ms_data_total_mzrt<-data.frame(ms_data_total_all$mz,ms_data_total_all$rt)
##### Filtering m/z features
#Removing features where the difference between rt min and rt-max is less than 1 seconds
ms_data_total<-ms_data_total_all[ms_data_total_all$rtmax-ms_data_total_all$rtmin > 1,]
temp_mz<-ms_data_total$mz;temp_rt<-ms_data_total$rt
#ms_data_total<-as.data.frame(sapply(ms_data_total[,15:71], as.numeric)) #for AR
ms_data_total<-as.data.frame(sapply(ms_data_total[,14:62], as.numeric)) #for PB
rownames(ms_data_total)<-paste0(temp_mz,'@',temp_rt)
str(ms_data_total)
colnames(ms_data_total)<-gsub('...2w_A.','',colnames(ms_data_total))# for AR
colnames(ms_data_total)<-gsub('..2wk_P.','',colnames(ms_data_total))# for PB
colnames(ms_data_total)<-gsub('blank','BLANK',colnames(ms_data_total))
colnames(ms_data_total)<-gsub('_','',colnames(ms_data_total))

# For AR 2 week dataset generated by Peter in xcms
# mzfilename<-"RiceMetabolomicsData.txt"
# ms_data_total<-read.table(mzfilename,sep="\t",header=T,check.names=FALSE,row.names=1)
# ms_data_total_mzrt<-rownames(ms_data_total)
# ms_data_total<-as.data.frame(sapply(ms_data_total, as.numeric))
# rownames(ms_data_total)<-ms_data_total_mzrt
# str(ms_data_total)
# colnames(ms_data_total)



####

ms_data_samples<-ms_data_total[, -grep('BLANK', colnames(ms_data_total))] #removing Blanks
ms_data_blank<-ms_data_total[, grep('BLANK', colnames(ms_data_total))] #only Blanks

SampleGroups<-sapply(names(ms_data_total), function(x) paste(strsplit(x,"")[[1]][1:2],collapse = ""))
SampleGroups<-as.vector(SampleGroups)

SampleGroups= stri_replace_all_fixed(SampleGroups,c('E1','E2','E3','E4'), c('EC'), vectorize_all=FALSE) #replacing group name as EC
SampleGroups= stri_replace_all_fixed(SampleGroups,c('R1','R2','R3','R4'), c('RL'), vectorize_all=FALSE) #replacing group name as RL
SampleGroups= stri_replace_all_fixed(SampleGroups,c('M1','M2','M3','M4'), c('MU'), vectorize_all=FALSE) #replacing group name as MU

## Comparing only samples whose RNAseq data is available

nonRNAseq <- "R|CO|BL"
ms_data_samples_rna<-ms_data_samples[, -grep(nonRNAseq, colnames(ms_data_samples))] #removing non-rnaseq samples
SampleGroups_rna<-SampleGroups[-grep(nonRNAseq, SampleGroups)] #removing non-rnaseq samples

nonRNAseq_wo <- "R|CO|BL|E1|WT3|M4" #without outlier replicates from rnaseq samples
ms_data_samples_rna_wo<-ms_data_samples[, -grep(nonRNAseq_wo, colnames(ms_data_samples))] #removing non-rnaseq samples
SampleGroups_rna_wo<-sapply(names(ms_data_samples_rna_wo), function(x) paste(strsplit(x,"")[[1]][1:2],collapse = ""))
SampleGroups_rna_wo<-as.vector(SampleGroups_rna_wo)
SampleGroups_rna_wo= stri_replace_all_fixed(SampleGroups_rna_wo,c('E1','E2','E3','E4'), c('EC'), vectorize_all=FALSE) #replacing group name as EC
SampleGroups_rna_wo= stri_replace_all_fixed(SampleGroups_rna_wo,c('R1','R2','R3','R4'), c('RL'), vectorize_all=FALSE) #replacing group name as RL
SampleGroups_rna_wo= stri_replace_all_fixed(SampleGroups_rna_wo,c('M1','M2','M3','M4'), c('MU'), vectorize_all=FALSE) #replacing group name as MU

########## Plotting MZ and RT of Time Series PB and 6 HR PBH

ms_data_total_mzrt$type<-"Total"
colnames(ms_data_total_mzrt)<-c('mz','rt','type')
mzrt_filtered<-data.frame(temp_mz,temp_rt);rm(temp_mz,temp_rt)
mzrt_filtered$type<-"Filtered1Sec"
colnames(mzrt_filtered)<-c('mz','rt','type')
mzrt_total<-rbind(ms_data_total_mzrt,mzrt_filtered)

#placeholder plot - prints nothing at all
empty <- ggplot()+geom_point(aes(1,1), colour="white") +
  theme(                              
    plot.background = element_blank(), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    panel.border = element_blank(), 
    panel.background = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  )

#scatterplot of x and y variables
scatter <- ggplot(mzrt_total,aes(rt,mz))  + geom_point(alpha=.3,aes(color=type)) + geom_rug(aes(col=type),alpha=.1) + 
  scale_color_manual(values = c("orange", "purple")) + ggtitle("RT vs MZ")+ 
  theme_bw() + theme(axis.text.x=element_text(hjust = 1,size=18),axis.text.y=element_text(size=18),
                     #panel.grid.major.x = element_blank(), # to x remove gridlines
                     #panel.grid.major.y = element_blank(), # to y remove gridlines
                     panel.border = element_blank(),  # remove top and right border
                     panel.background = element_blank(),
                     axis.line = element_line(color = 'black'),
                     legend.position=c(1,1),legend.justification=c(1,1))+
  xlab(paste0("Retention time(s)","\n","All Features= ",nrow(ms_data_total_mzrt)," Filtered1Sec Features= ",nrow(mzrt_filtered)))

#marginal density of x - plot on top
plot_top <- ggplot(mzrt_total, aes(rt, fill=type)) + 
  geom_density(alpha=.5) + 
  scale_fill_manual(values = c("orange", "purple")) + 
  theme(legend.position = "none")

#marginal density of y - plot on the right
plot_right <- ggplot(mzrt_total, aes(mz, fill=type)) + 
  geom_density(alpha=.5) + 
  coord_flip() + 
  scale_fill_manual(values = c("orange", "purple")) + 
  theme(legend.position = "none") 

#arrange the plots together, with appropriate height and width for each row and column
#grid.arrange(plot_top, empty, scatter, plot_right, ncol=2, nrow=2, widths=c(4, 1), heights=c(1, 4))

grobframe <- arrangeGrob(plot_top, empty, scatter, plot_right, ncol=2, nrow=2, widths=c(4, 1), heights=c(1, 4),
                         main = textGrob("PB dataset", gp = gpar(fontsize=18, fontface="bold.italic")))

ggsave("mzrt_PB.pdf",grobframe, height=12, width=12)



#######################################
###### Exploratory data analysis ######
#######################################

## Functions

ScaleData<-function(data_matrix){
  data_matrix<-as.matrix(log1p(data_matrix))
  processed_data<-scale(data_matrix,center=T,scale=T)
  colnames(processed_data)<-colnames(data_matrix)
  rownames(processed_data)<-rownames(data_matrix)
  return(processed_data)
}
normalizeData<-function(data_matrix){
  data_matrix<-as.matrix(log1p(data_matrix))
  processed_data<-normalize.quantiles(as.matrix(data_matrix),copy=TRUE)
  colnames(processed_data)<-colnames(data_matrix)
  rownames(processed_data)<-rownames(data_matrix)
  return(processed_data)
}
compute_pca<-function(dataset,preprocess_method) {
  dataset<-as.matrix(log1p(dataset)) #log transform the data using natural log
  if(preprocess_method=="norm") {
    processed_data<-normalize.quantiles(as.matrix(dataset),copy=TRUE)
  }   else  {
    processed_data<-scale(dataset,center=T,scale=T)
    processed_data<-processed_data-min(processed_data)
  }
  pca_results <- princomp(processed_data,cor=F,scores=T) ### IMP: choose quantile normalized or scaled data
  return(pca_results)
}

# for only a single dataframe
compute_perm_ftest<-function(dataset,classlabel) {
  dataset_sig_features<-mt.maxT(dataset,classlabel,test="f",side="abs",fixed.seed.sampling="y",B=1000,nonpara="n")
  p.values<-dataset_sig_features
  id.sig_dataset <- sort(dataset_sig_features[dataset_sig_features$adjp < 0.05,c(1)])
  metab_sig<-cbind(dataset[id.sig_dataset,],round(dataset_sig_features$adjp[dataset_sig_features$index %in% id.sig_dataset],5))
  return(list(p.values,metab_sig))
}

# for only a single dataframe such as those of uncorrected data
compute_r2_from_fvalue_singleDataFrame<-function(dataset,classlabel) {
  classlabel_factor<-as.numeric(as.factor(classlabel))-1
  fval_teststat<-as.data.frame(matrix(NA,nrow(dataset),1))
  r2_teststat<-as.data.frame(matrix(NA,nrow(dataset),1))
  data_matrix<-as.matrix(dataset)
  dataset_fvalue<-mt.teststat(data_matrix,classlabel_factor,test="f",nonpara="n")
  dataset_r2<-r2.from.Fstat(dataset_fvalue,length(unique(classlabel)),ncol(data_matrix))
  fval_teststat[,1]<-dataset_fvalue
  r2_teststat[,1]<-dataset_r2
  return (list(fval_teststat,r2_teststat))
}

gg_color_hue <- function(n) {
  hues = seq(15, 375, length=n+1)
  hcl(h=hues, l=65, c=100)[1:n]
}

compute_linearModel_associations<-function(results.from.pca,dataType,Species,GrowthStage) {
  lm_pca_scores<-apply(results.from.pca$loadings,2, function(x) {
    #lm_val<-lm(x~ as.factor(dataType) + as.factor(Species) + as.factor(GrowthStage))#
    lm_val<-lm(x~ as.factor(dataType) + as.factor(dataType)/as.factor(Species) + as.factor(dataType)/as.factor(Species)/as.factor(GrowthStage)) #using a nested model
    lm_cor<-summary(lm_val)
    p.val_model<-anova(lm_val)$'Pr(>F)'[1:3]
    fvalue_model<-anova(lm_val)$'F value'[1:3] # modified by shiv to return r2 for each model term on 09-Jan 2015
    r2_model<-anova(lm_val)$'Sum Sq'/sum(anova(lm_val)$'Sum Sq') #includes the r2 term for residuals
    r2_model<-r2_model[1:3] #includes the r2 term only for runday and runday/strain
    return(list(lm_cor$r.squared,p.val_model,fvalue_model,r2_model))
  })
}

extract.variables.pc.associations<-function(linearmodel_list,variable.extract) {
  if(variable.extract=="r2model") { #WARNING:code implictly assumes r2 is in the first column and p.val in the second
    return (sapply(linearmodel_list, function(x){as.numeric(x[1])}))
  } else if (variable.extract=="pvalue"){
    return (sapply(linearmodel_list, function(x){x[2]}))
  } else if (variable.extract=="fvalue"){
    return (sapply(linearmodel_list, function(x){x[3]}))
  } else {
    return (sapply(linearmodel_list, function(x){x[4]}))
  }
}

#### PCA

dataForPlotting<-ms_data_samples_rna
ms_data_princomp<-compute_pca(dataForPlotting,"norm")
residual_variance<-ms_data_princomp$sdev^2/sum(ms_data_princomp$sdev^2)

plot(ms_data_princomp$loadings[,2]~ms_data_princomp$loadings[,1])
text(ms_data_princomp$loadings[,2]~ms_data_princomp$loadings[,1], labels = colnames(dataForPlotting), cex=0.6, pos=4)

### PCA ggplot
forPlot<-data.frame(PCaxisA = ms_data_princomp$loadings[,1],PCaxisB = ms_data_princomp$loadings[,2], 
                    dataType=SampleGroups_rna) #Subset SampleGroups as the last 9 are blanks

##plotting
plot1<- ggplot(data=forPlot, aes(x=PCaxisA, y=PCaxisB, colour= factor(dataType), shape= factor(dataType))) + geom_point(size=4) #dataType
plot2<- plot1 +  geom_text(data = forPlot, aes(x=PCaxisA, y=PCaxisB, label= colnames(dataForPlotting)), hjust = 1) +
  theme_bw() + theme(axis.text.x=element_text(angle = 45, hjust = 1,size=12),axis.text.y=element_text(size=12),
                                  panel.grid.major.x = element_blank(), # to x remove gridlines
                                  panel.grid.major.y = element_blank(), # to y remove gridlines
                                  panel.border = element_blank(),  # remove top and right border
                                  panel.background = element_blank(),
                                  axis.line = element_line(color = 'black'))+ 
                                  xlab(paste0("PC 1 loadings","\n","Variation exp= ",round(residual_variance[1]*100,2),"%")) + 
                                  ylab(paste0("PC 2 loadings","\n","Variation exp= ",round(residual_variance[2]*100,2),"%")) +
                                  ggtitle("PCA Samples - (metabolomics data for samples with rnaseq + without outliers)")


pdf("pca_pc12_samples_rna_PB.pdf",height=12,width=12)
plot2
dev.off()


###########################################################
################ Differential Analysis ####################

# Permanova Samples
a<-adonis(t(normalizeData(log1p(ms_data_samples_rna)))~ SampleGroups_rna, method = "bray", perm=999)
  
# Log transform and quantile normalization
ms_data_samples_rna_norm<-normalizeData(ms_data_samples_rna) #metabolomics data for RNA samples

#permutational analysis
classlabel<-as.numeric(as.factor(SampleGroups_rna))-1
ms_data_samples_rna_perm<-compute_perm_ftest(ms_data_samples_rna_norm, classlabel)
ms_data_samples_rna_perm_pval<-ms_data_samples_rna_perm[[1]]
ms_data_samples_rna_perm_pval$BHadj<-p.adjust(as.numeric(ms_data_samples_rna_perm_pval$rawp),method="BH")
ms_data_samples_rna_perm_matrix<-ms_data_samples_rna_perm[[2]]
# > dim(ms_data_samples_rna_perm_matrix)
# [1] 552  25 # AR by PB #WITHOUT 1 SEC (RT) FILTER
# [1] 742   25 # AR by SU
# [1] 608   25 # PB by SU

png("pvalue_rna_metabolomics_PB.png")
hist(ms_data_samples_rna_perm_pval$rawp,xlab=paste0("Diff features (adj p<0.05) = ",nrow(ms_data_samples_rna_perm_matrix)))
dev.off()

## Wilcox test
# Comparing WT with MU
a.list <- apply(ms_data_samples_rna_norm,1,function(x){wilcox.test(x[9:16],x[17:24],paired=TRUE,var.equal=F,p.adj=BH,exact=F)$p.value})
id.sig <- which(a.list < 0.05 );
metab.sig_WTvsMU<-ms_data_samples_rna_norm[id.sig,]
#nrow(metab.sig_WTvsMU)
#694 # AR BY PB #WITHOUT 1 SEC (RT) FILTER
#604 # AR by SU
#649 # PB by SU
WTvsMU_pvalues<-a.list[id.sig]
WTvsMU_foldchange<-apply(metab.sig_WTvsMU,1,function(x){foldchange(mean(x[17:24]),mean(x[9:16]))}) #computing WT/MU

mz_rt <- strsplit(rownames(metab.sig_WTvsMU), "\\@")
mz<-as.numeric(sapply(mz_rt , function (x) if(length(x) == 2) x[1] else as.character(NA)))
rt<-sapply(mz_rt , function (x) if(length(x) == 2) x[2] else as.character(NA))
WTvsMU_mass.list<-data.frame(round(mz,5),rt,round(as.numeric(WTvsMU_pvalues),5),
                        round(as.numeric(WTvsMU_foldchange),5))
colnames(WTvsMU_mass.list)<-c("MZ","RT","P-VALUE","FoldChange(WT/MU)")
write.table(WTvsMU_mass.list,"differential_PB_WTvsMU_massFeatures.txt",sep="\t",quote=FALSE)
write.table(metab.sig_WTvsMU,"differential_PB_WTvsMU.txt",quote=FALSE,row.names=FALSE,sep="\t")

# Comparing WT with EC
a.list <- apply(ms_data_samples_rna_norm,1,function(x){wilcox.test(x[1:8],x[17:24],paired=TRUE,var.equal=F,p.adj=BH,exact=F)$p.value})
id.sig <- which(a.list < 0.05 );
metab.sig_WTvsEC<-ms_data_samples_rna_norm[id.sig,]
#nrow(metab.sig_WTvsEC)
#1666 # AR by PB #WITHOUT 1 SEC (RT) FILTER
#973 # AR by SU
#1277 # PB by SU

WTvsEC_pvalues<-a.list[id.sig]
WTvsEC_foldchange<-apply(metab.sig_WTvsEC,1,function(x){foldchange(mean(x[17:24]),mean(x[1:8]))}) #computing WT/EC

mz_rt <- strsplit(rownames(metab.sig_WTvsEC), "\\@")
mz<-as.numeric(sapply(mz_rt , function (x) if(length(x) == 2) x[1] else as.character(NA)))
rt<-sapply(mz_rt , function (x) if(length(x) == 2) x[2] else as.character(NA))
WTvsEC_mass.list<-data.frame(round(mz,5),rt,round(as.numeric(WTvsEC_pvalues),5),
                        round(as.numeric(WTvsEC_foldchange),5))
colnames(WTvsEC_mass.list)<-c("MZ","RT","P-VALUE","FoldChange(WT/EC)")
write.table(WTvsEC_mass.list,"differential_PB_WTvMU_massFeatures.txt",sep="\t",quote=FALSE)
write.table(metab.sig_WTvsEC,"differential_PB_WTvsEC.txt",quote=FALSE,row.names=FALSE,sep="\t")

##### Plotting boxplots of samples
png('boxplot_positive.png',width=8000)
boxplot(as.data.frame(normalizeData(log1p(ms_data_samples_rna))),range=0,xlab="Samples",ylab="Log2 feature counts",las=1,cex.axis=0.7)
dev.off()

#Plotting TICs
mzxmlfiles<-list.files("J:/F_projects/Projects/NUS/RiceProject/Metabolomics/rawData/2 week PB/EC",pattern=".mzXML",full.names=TRUE) # Get filenames with a given pattern and include subdirectories 
getTICs(files=mzxmlfiles,pdfname=paste("PB_EC.pdf", sep = ""),rt="raw")

######### TIC overlays #############################################
getTIC <- function(file,rtcor=NULL) {
  object <- xcmsRaw(file)
  cbind(if (is.null(rtcor)) object@scantime else rtcor, rawEIC(object,mzrange=range(object@env$mz))$intensity) 
}
##  overlay TIC from all files in current folder or from xcmsSet, create pdf
getTICs <- function(xcmsSet=NULL,files=NULL, pdfname="TICs.pdf",rt=c("raw","corrected")) {
  if (is.null(xcmsSet)) {
    filepattern <- c("[Cc][Dd][Ff]", "[Nn][Cc]", "([Mm][Zz])?[Xx][Mm][Ll]",
                     "[Mm][Zz][Dd][Aa][Tt][Aa]", "[Mm][Zz][Mm][Ll]")
    filepattern <- paste(paste("\\.", filepattern, "$", sep = ""), collapse = "|")
    if (is.null(files))
      files <- getwd()
    info <- file.info(files)
    listed <- list.files(files[info$isdir], pattern = filepattern,
                         recursive = TRUE, full.names = TRUE)
    files <- c(files[!info$isdir], listed)
  } else {
    files <- filepaths(xcmsSet)
  }
  N <- length(files)
  TIC <- vector("list",N)
  
  for (i in 1:N) {
    cat(files[i],"\n")
    if (!is.null(xcmsSet) && rt == "corrected")
      rtcor <- xcmsSet@rt$corrected[[i]] else 
        rtcor <- NULL
    TIC[[i]] <- getTIC(files[i],rtcor=rtcor)
  }
  pdf(pdfname,w=16,h=10)
  cols <- rainbow(N)
  lty = 1:N
  pch = 1:N
  xlim = range(sapply(TIC, function(x) range(x[,1])))
  ylim = range(sapply(TIC, function(x) range(x[,2])))
  plot(0, 0, type="n", xlim = xlim, ylim = ylim, main = "Total Ion Chromatograms", xlab = "Retention Time", ylab = "TIC")
  for (i in 1:N) {
    tic <- TIC[[i]]
    points(tic[,1], tic[,2], col = cols[i], pch = pch[i], type="l")
  }
  legend("topright",paste(basename(files)), col = cols, lty = lty, pch = pch)
  dev.off()
  
  invisible(TIC)
}


#### multi plot ###

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
   numPlots = length(plots)
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
   if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

